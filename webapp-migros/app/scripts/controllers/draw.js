/*global pmw, $*/pmw.Controllers = pmw.Controllers || {};(function(global) {    'use strict';    var ctx, x, y = null;    var loader = null;    var strokes;    var foregroundColor = '#000000';    var lineWidth = 0.001;    var canvas;    var oversampling = 2;    var windowParams = {};    var zoomFactor = 1 / oversampling;    var zoomOffset = {x: 0, y: 0};    var currentStroke = {};    var oldX = 0;    var oldY = 0;    // Used for the drawing timer    var timer = 0;    var recording = false;    var lastDate = new Date();    var lastStrokeEndTimerValue = 0;    var MAX_UNDO_AMOUNT = 10;    var oldCanvases = [];    var currentCanvas = null;    var TIMER_UPDATE_FREQ = 1000;    var lastTimerUpdate = 0;    var DRAWING_SEND_FREQ = 60 * 5 * 1000;    var lastDrawingSend = 0;    function usx(x) {        return (x - windowParams.originX) * $(canvas).outerWidth() / windowParams.scaleX;    }    function usy(y) {        return (y - windowParams.originY) * $(canvas).outerHeight() / windowParams.scaleY;    }    function uss(s) {        return s / windowParams.scaleX;    }    function sx(x) {        return x / $(canvas).outerWidth() * windowParams.scaleX + windowParams.originX;    }    function sy(y) {        return y / $(canvas).outerHeight() * windowParams.scaleY + windowParams.originY;    }    function ss(s) {        return s * windowParams.scaleX;    }    function saveStrokes() {        // localStorage.setItem('Strokes', strokes);        var now = new Date().getTime();        if (now - lastDrawingSend > DRAWING_SEND_FREQ) {            lastDrawingSend = new Date().getTime();            $.ajax({                url: global.pmw.options.serverUrl + '/tmpDrawing',                type: 'post',                contentType: 'application/json; charset=utf-8',                data: JSON.stringify({                    strokes: strokes,                }),            }).done(function(data) {                localStorage.setItem('HasBackup', true);            });            //loader = M.LoaderView.create().render().show();        }    }    function beginStroke(x,y){        // sendStroke(false);        oldX = x;        oldY = y;        var strokePartNormalized = {            x: sx(x),             y: sy(y),            timerAt: timer        };                var newStroke = {            dateStart:(new Date()),            timerStart: timer,            points:[strokePartNormalized],            color:foregroundColor,            lineWidth:ss(lineWidth)        };        currentStroke = newStroke;        strokes.push(newStroke);        drawLine(lineWidth * $(canvas).outerWidth(), foregroundColor, x, y, x + 0.1, y + 0.1);        if (currentCanvas != null)            oldCanvases.unshift(currentCanvas);    }        function stroke(x,y){        ctx.lineWidth = lineWidth;        ctx.strokeStyle = foregroundColor;        drawLine(lineWidth * $(canvas).outerWidth(), foregroundColor, oldX, oldY, x, y)        oldX = x;        oldY = y;                var strokePart = {x: x, y: y};        var strokePartNormalized = {            x: sx(x),            y: sy(y),            timerAt: timer        }                strokes[strokes.length-1].points.push(strokePartNormalized);        currentStroke.points.push(strokePartNormalized);    }        function endStroke(){        currentStroke.timerEnd = timer;        saveStrokes();        if (oldCanvases.length >= MAX_UNDO_AMOUNT) {            oldCanvases.pop();        }        saveState();        this.contentView.childViews.tools.childViews.undo.enable();    }        function drawLine(width, color, x1, y1, x2, y2){        ctx.save();        ctx.beginPath();        ctx.lineCap = 'round';        ctx.lineJoin = 'round';        ctx.strokeStyle = color;        ctx.lineWidth = width;        ctx.moveTo(x1,y1);        ctx.lineTo(x2,y2);        ctx.stroke();        ctx.restore();    }    function saveState() {        currentCanvas = ctx.getImageData(0, 0, canvas.width, canvas.height);    }    pmw.Controllers.DrawController = pmw.Controllers.AbstractController.extend({        pageHeadline: 'Dessin',        selectionSize: M.Model.create({            size: 5        }),        strokesMin: 10,        palette: [            ['FFFFFF', 'DADADA', 'D0CDCA', '808080', '666261', '000000'],            ['F9E813', 'F8C82F', 'FBFA0D', 'F89618'],            ['6CE013', '258400', '45B7F9', '4680E8', '3800EB', '44FF00'],            ['6300A1','CA8BF6','8C0EF4','F687FC','EA00E4','4EFFE6'],            ['FBE2B7','FA6F76','ED001D','F2A263','8B4212','40C9B9']        ],        backgroundColor: null,        _initViews: function() {            backRoute = "#chooseFeature";            // Create the ContentView with the controller (this) as scope            if (!this.contentView) {                this.contentView = pmw.Views.DrawView.create(this, null, true);            }            // Create the HeaderView with the controller (this) as scope            if (!this.headerView) {                this.headerView = pmw.Views.BackheaderView.create(this, null, true);            }            this._applyViews();            var current = this;            var flatPalette = [];            for (var i in this.palette) {                for (var j in this.palette[i]) {                    flatPalette.push(this.palette[i][j]);                }            }            if (!localStorage.getItem('Background'))                this.backgroundColor = '#' + flatPalette[Math.floor(Math.random() * flatPalette.length)];            $('.colorpicker.background input').spectrum({                showPaletteOnly: true,                showPalette: true,                color: current.backgroundColor,                palette: current.palette,                change: function(color) {                    current.setBackgroundColor(color.toHexString());                    localStorage.setItem('Background', color.toHexString());                }            });            $('.colorpicker.foreground input').spectrum({                showPaletteOnly: true,                showPalette: true,                color: foregroundColor,                palette: current.palette,                change: function(color) {                    foregroundColor = color.toHexString();                    localStorage.setItem('Foreground', color.toHexString());                }            });            $('.selectionSize .selection-list').sizeChooser(this.changeSize);            windowParams = {                width: global.pmw.options.winWidth,                height: global.pmw.options.winHeight,                mask: "images/mask-approximate.png",                originX: 0,                originY: 0,                scaleX: 1,                scaleY: 1            };            this.timerInterval = setInterval(this.onTimer.bind(this), 1);            this.newCanvas();            this.contentView.childViews.panControls.childViews.moveLeft.disable();            this.contentView.childViews.panControls.childViews.moveRight.disable();             this.contentView.childViews.panControls.childViews.moveUp.disable();            this.contentView.childViews.panControls.childViews.moveDown.disable();            this.contentView.childViews.tools.childViews.zoomOut.disable();            this.contentView.childViews.tools.childViews.pause.disable();            this.contentView.childViews.tools.childViews.undo.disable();        },        updateTimerDisplay: function () {            var dur = moment.duration(timer);            $('.timer .value').html(dur.format('HH:mm:ss', {trim: false}));            this.contentView.childViews.tools.childViews.timer.value = dur.format('HH:mm:ss', {trime: false});            this.contentView.childViews.tools.childViews.timer.updateTemplate();        },        onTimer: function() {            var now = new Date();            var dt = now.getTime() - lastDate.getTime();            lastDate = now;            if (recording) {                timer += dt;            }            if (now.getTime() - lastTimerUpdate > TIMER_UPDATE_FREQ && recording) {                lastTimerUpdate = now.getTime();                this.updateTimerDisplay();            }        },        pause: function() {            recording = false;            this.contentView.childViews.tools.childViews.pause.disable();            this.contentView.childViews.tools.childViews.record.enable();            this.stopTest();        },        record: function() {            recording = true;            this.contentView.childViews.tools.childViews.pause.enable();            this.contentView.childViews.tools.childViews.record.disable();            // this.startTest();        },        zoomIn: function () {            this.contentView.childViews.panControls.childViews.moveLeft.enable();            this.contentView.childViews.panControls.childViews.moveRight.enable();             this.contentView.childViews.panControls.childViews.moveUp.enable();            this.contentView.childViews.panControls.childViews.moveDown.enable();            this.contentView.childViews.tools.childViews.zoomOut.enable();            zoomFactor += 0.25;            this.updateZoomPan();        },        zoomOut: function () {            this.contentView.childViews.tools.childViews.zoomIn.enable();            zoomFactor -= 0.25;            // zoomOffset.x = 0;            this.updateZoomPan();        },        moveLeft: function () {            zoomOffset.x -= 0.1 / zoomFactor;            if (zoomOffset.x < 0)                 zoomOffset.x = 0;            this.updateZoomPan();        },        moveRight: function () {            zoomOffset.x += 0.1 / zoomFactor;            this.updateZoomPan();        },        moveUp: function () {            zoomOffset.y -= 0.1 / zoomFactor;            this.updateZoomPan();        },        moveDown: function () {            zoomOffset.y += 0.1 / zoomFactor;            this.updateZoomPan();        },        updateZoomPan: function () {            if (zoomFactor <= 1 / oversampling) {                zoomOffset.x = 0;                zoomOffset.y = 0;                zoomFactor = 1 / oversampling;                this.contentView.childViews.tools.childViews.zoomOut.disable();                this.contentView.childViews.tools.childViews.zoomIn.enable();                this.contentView.childViews.panControls.childViews.moveLeft.disable();                this.contentView.childViews.panControls.childViews.moveRight.disable();                 this.contentView.childViews.panControls.childViews.moveUp.disable();                this.contentView.childViews.panControls.childViews.moveDown.disable();                          } else if (zoomFactor >= 3) {                zoomFactor = 3;                this.contentView.childViews.tools.childViews.zoomOut.enable();                this.contentView.childViews.tools.childViews.zoomIn.disable();                this.contentView.childViews.panControls.childViews.moveLeft.disable();                this.contentView.childViews.panControls.childViews.moveRight.disable();                 this.contentView.childViews.panControls.childViews.moveUp.disable();                this.contentView.childViews.panControls.childViews.moveDown.disable();                 } else {                this.contentView.childViews.tools.childViews.zoomOut.enable();                this.contentView.childViews.tools.childViews.zoomIn.enable();                this.contentView.childViews.panControls.childViews.moveLeft.enable();                this.contentView.childViews.panControls.childViews.moveRight.enable();                 this.contentView.childViews.panControls.childViews.moveUp.enable();                this.contentView.childViews.panControls.childViews.moveDown.enable();                 }            if (zoomOffset.x < 0)                 zoomOffset.x = 0;            if (zoomOffset.y > 0.9)                 zoomOffset.y = 0.9;            if (zoomOffset.y < 0)                 zoomOffset.y = 0;            if (zoomOffset.x > 0.9)                 zoomOffset.x = 0.9;                        $("#contentCanvas").css({                transform: 'scale(' + zoomFactor + ') translate(' + (-zoomOffset.x * $(canvas).width()) + 'px, ' + (-zoomOffset.y * $(canvas).height()) + 'px)',                // left: (- zoomOffset.x * zoomFactor * 100) + '%',                // top: (- zoomOffset.y * zoomFactor * 100) + '%'             });        },        getCanvasBounds: function() {               this.canvasOriginY = $(canvas).offset().top;            this.canvasOriginX = $(canvas).offset().left;        },        setBackgroundColor: function(color) {            this.backgroundColor = color;            localStorage.setItem('Background', color);            $('.colorpicker.background input').spectrum('set', color.replace('#', ''));            //$('#contentCanvas canvas').css('background-color', this.backgroundColor);            ctx.fillStyle = color; // set canvas background color            ctx.fillRect(0, 0, canvas.width, canvas.height); // now fill the canvas            ctx.fillStyle = foregroundColor;            this.repaint();        },        newCanvas: function() {            //define and resize canvas            //$('#contentCanvas').height($(window).height()-100);            canvas = '<canvas id="canvas" width="' + $(window).width() + '" height="' + ($(window).height() - $('.toolbarview').height() - $('.tools').height()) + '"></canvas><div class="after"></div>';            $('#contentCanvas').html(canvas);            canvas = $('#contentCanvas canvas')[0];            // setup canvas            ctx = $('#contentCanvas canvas')[0].getContext('2d');            window.addEventListener('resize', this.resizeWindow.bind(this), false);            window.addEventListener('orientationchange', this.resizeWindow.bind(this), false);            this.resizeCanvas();            if (localStorage.getItem('HasBackup') !== null) {                loader = M.LoaderView.create().render().show();                $.get(global.pmw.options.serverUrl + '/tmp-drawings/drawing.json', function (data) {                    strokes = data.strokes;                    this.repaint();                    if (strokes.length != 0) {                        timer = strokes[strokes.length - 1].timerEnd;                        if (typeof timer === 'undefined') {                            timer = 0;                        }                    } else {                        timer = 0;                    }                    this.updateTimerDisplay();                    loader.hide();                }.bind(this)).fail(function () {                    loader.hide();                })            } else {                strokes = [];            }            if (localStorage.getItem('Foreground'))                ctx.strokeStyle = localStorage.getItem('Foreground');            else                ctx.strokeStyle = foregroundColor;            ctx.lineWidth = lineWidth;            ctx.lineCap = 'round';            ctx.lineJoin = 'round';            if (localStorage.getItem('Background'))                this.setBackgroundColor(localStorage.getItem('Background'));            else                this.setBackgroundColor(this.backgroundColor);            // setup to trigger drawing on mouse or touch            $('#contentCanvas canvas').drawTouch(this);            $('#contentCanvas canvas').drawPointer(this);            $('#contentCanvas canvas').drawMouse(this);            this.getCanvasBounds();            saveState();            // $('#facebook').click(postToWall);        },        clearDrawPress: function () {            if (strokes.length != 0) {                if (!confirm('Voulez-vous vraiment tout effacer?'))                    return;            }            this.clearDraw();        },        clearDraw: function() {            var flatPalette = [];            for (var i in this.palette) {                for (var j in this.palette[i]) {                    flatPalette.push(this.palette[i][j]);                }            }            strokes = [];            oldCanvases = [];            currentCanvas = null;            this.setBackgroundColor('#' + flatPalette[Math.floor(Math.random() * flatPalette.length)]);            localStorage.removeItem('Background');            localStorage.removeItem('HasBackup');            localStorage.removeItem('Foreground');            this.newCanvas();            timer = 0;            this.updateTimerDisplay();            this.pause();        },        changeSize: function(){            var scale = ctx.canvas.width / windowParams.width;            lineWidth = $('.selectionSize select').val() / 1000.0;            ctx.lineWidth = lineWidth;        },        undo: function() {            console.log(oldCanvases);            if (oldCanvases.length === 0)                return;            strokes.pop();            if (strokes.length != 0)                timer = strokes[strokes.length - 1].timerEnd;            else                timer = 0;            this.pause();            this.updateTimerDisplay();            ctx.clearRect(0, 0, canvas.width, canvas.height);            currentCanvas = oldCanvases.splice(0, 1)[0];            ctx.putImageData(currentCanvas, 0, 0);            if (oldCanvases.length === 0) {                this.contentView.childViews.tools.childViews.undo.disable();            }            // this.repaint();            saveStrokes();        },        saveDraw: function() {            var current = this;            $('<div title="Confirmation">Envoyer le dessin ?</div>').dialog({                resizable: false,                height: 200,                modal: true,                draggable: false,                buttons: {                    Non: function() {                        $(this).dialog('close');                    },                    Oui: function() {                        var imageData = strokes;                        console.log(imageData);                        current.stopTest();                        $.ajax({                            url: global.pmw.options.serverUrl + '/drawing',                            type: 'post',                            contentType: 'application/json; charset=utf-8',                            data: JSON.stringify({                                duration: timer,                                action: 'newDrawing',                                strokes: imageData,                                width: canvas.width,                                height: canvas.height,                                groupId: global.pmw.options.drawingWindowGroup,                                backgroundColor: current.backgroundColor                            }),                        }).done(function(data) {                            data = jQuery.parseJSON(data);                            if (data.responseType == 'ok') {                                M.Toast.show('Ton dessin a été envoyé! Nos modérateurs vont y jeter un oeil.');                                current.clearDraw();                            } else {                                M.Toast.show('Erreur lors de l\'envoi ! :( Es-tu connecté à internet?');                            }                        });                        $(this).dialog('close');                    }                }            });        },        resizeWindow: function() {            var winWidth = $(window).width();            var heightMargin = $('.header').height() + $('.tools').height();            var winHeight = $(window).height() - winHeight;            var canvasWidth = canvas.width;            var canvasHeight = canvas.height;            var newZoom = winWidth / canvasWidth;            if (newZoom * canvasHeight > winHeight)                newZoom = winHeight / canvasHeight;            zoomFactor = newZoom;            zoomOffset = {x: 0, y: 0};            this.updateZoomPan();        },        resizeCanvas: function() {            console.log("resizeCanvas");            var ratio = windowParams.height / windowParams.width;            $("#contentCanvas .after").css({                backgroundImage: "url(" + windowParams.mask + ")",            });            var winHeight = $(window).height();            var winWidth = $(window).width();            var newWidth = 0;            var newHeight = 0;            var heightMargin = $('.header').height() + $('.tools').height();            // windows size without header and footer            winHeight = winHeight - heightMargin;            if( winWidth/winHeight < 1/ratio) { // Portrait                newWidth = winWidth;                newHeight = newWidth * ratio;            } else { // Landscape                newHeight = winHeight;                newWidth = newHeight / ratio;            }            newWidth *= oversampling;            newHeight *= oversampling;            $('#contentCanvas').width(newWidth);            $('#contentCanvas').height(newHeight);            canvas.width = newWidth;            canvas.height = newHeight;                        ctx.strokeStyle = foregroundColor;            ctx.lineWidth = lineWidth;            ctx.lineCap = 'round';            ctx.lineJoin = 'round';            this.repaint();            this.updateZoomPan();        },        repaint: function() {            if (strokes) {                ctx.fillStyle = this.backgroundColor;                ctx.clearRect(0, 0, canvas.width, canvas.height);                ctx.fillRect(0, 0, canvas.width, canvas.height);                for (var i = 0; i < strokes.length; i++) {                    for (var j = 0; j < strokes[i].points.length - 1; j++) {                        drawLine(                            uss(strokes[i].lineWidth) * $(canvas).outerWidth(),                            strokes[i].color,                            usx(strokes[i].points[j].x),                            usy(strokes[i].points[j].y),                            usx(strokes[i].points[j + 1].x),                            usy(strokes[i].points[j + 1].y)                        );                    }                }            }        },        startTest: function () {            var w = $(canvas).width();            var h = $(canvas).height();            var testData = {                x: Math.random() * w,                y: Math.random() * y,                vx: Math.random() * 2,                vy: Math.random() * 2            };            var strokeStarted = false;            function nextTestPoint(){                if (!strokeStarted ) {                    testData = {                        x: Math.random() * w,                        y: Math.random() * h,                        vx: Math.random() * 2 - 1,                        vy: Math.random() * 2 - 1                    };                    var randRow = Math.floor(Math.random() * this.palette.length);                    foregroundColor = "#" + this.palette[randRow][Math.floor(Math.random() * this.palette[randRow].length)];                    lineWidth = Math.random() * 0.05 + 0.003;                    beginStroke.call(this, testData.x, testData.y);                    strokeStarted = true;                } else {                    if (Math.random() < 0.01){                        endStroke.call(this);                        strokeStarted = false                        return;                    }                    testData.x += testData.vx * 3;                    testData.y += testData.vy * 3;                    testData.vx += Math.random() * 0.5 - 0.25;                    testData.vy += Math.random() * 0.5 - 0.25;                    if (testData.x > w){                        testData.vx *= -1;                        testData.x = w - 10;                    }                    if (testData.x < 0){                        testData.vx *= -1;                        testData.x = 10;                    }                    if (testData.y > h){                        testData.vy *= -1;                        testData.y = h - 10;                    }                    if (testData.y < 0){                        testData.vy *= -1;                        testData.y = 10;                    }                    stroke.call(this, testData.x, testData.y)                }            }            this.testInterval = setInterval(nextTestPoint.bind(this), 30);        },        stopTest: function () {            clearInterval(this.testInterval);        }    });    // prototype to start drawing on touch using canvas moveTo and lineTo    $.fn.drawTouch = function(controller) {        var start = function(e) {            e.preventDefault();            if (!recording)                return;            controller.getCanvasBounds();            e = e.originalEvent;            x = e.changedTouches[0].pageX - controller.canvasOriginX;            y = e.changedTouches[0].pageY - controller.canvasOriginY;            beginStroke.call(controller, x / zoomFactor, y / zoomFactor)        };        var move = function(e) {            e.preventDefault();            if (!recording)                return;                        e = e.originalEvent;            x = e.changedTouches[0].pageX - controller.canvasOriginX;            y = e.changedTouches[0].pageY - controller.canvasOriginY;            stroke.call(controller, x / zoomFactor, y / zoomFactor);        };        var stop = function(e) {            e.preventDefault();            if (!recording)                return;            endStroke.call(controller);        };        $(this).on('touchstart', start.bind(this));        $(this).on('touchmove', move.bind(this));        $(this).on('touchend', stop.bind(this));    };            // prototype to start drawing on pointer(microsoft ie) using canvas moveTo and lineTo    $.fn.drawPointer = function(controller) {        var start = function(e) {            e.preventDefault();            if (!recording)                return;            controller.getCanvasBounds();            e = e.originalEvent;            x = e.pageX - controller.canvasOriginX;            y = e.pageY - controller.canvasOriginY;            beginStroke.call(controller, x / zoomFactor, y / zoomFactor);        };        var move = function(e) {            e.preventDefault();            if (!recording)                return;            e = e.originalEvent;            x = e.pageX - controller.canvasOriginX;            y = e.pageY - controller.canvasOriginY;            stroke.call(controller, x / zoomFactor, y) / zoomFactor;        };        var stop = function(e){            e.preventDefault();            if (!recording)                return;            endStroke.call(controller);        }        $(this).on('MSPointerDown', start);        $(this).on('MSPointerMove', move);        $(this).on('MSPointerUp', stop);    };    // prototype to start drawing on mouse using canvas moveTo and lineTo    $.fn.drawMouse = function(controller) {        var clicked = 0;        var start = function(e) {            if (!recording)                return;            controller.getCanvasBounds();            x = e.pageX - controller.canvasOriginX;            y = e.pageY - controller.canvasOriginY;            beginStroke.call(controller, x / zoomFactor, y / zoomFactor);            clicked = 1;        };        var move = function(e) {            if (!recording)                return;            if(clicked){                x = e.pageX - controller.canvasOriginX;                y = e.pageY - controller.canvasOriginY;                stroke.call(controller, x / zoomFactor, y / zoomFactor);            }        };        var stop = function() {            if (!recording)                return;            if (clicked)                endStroke.call(controller);            clicked = 0;        };        $(this).on('mousedown', start);        $(this).on('mousemove', move);        $(window).on('mouseup', stop);    };})(this);