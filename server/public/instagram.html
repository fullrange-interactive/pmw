<html>
<head>
<link rel="stylesheet" type="text/css" href="styles.css" />
</head>
<body>

<div class="grid"></div>

<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/packery/2.0.0/packery.pkgd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/locale/fr.js"></script>
<script>

var grid = $('.grid').packery({
  itemSelector: '.grid-item'
});


/**
 * textFit v2.1.1
 * Previously known as jQuery.textFit
 * 11/2014 by STRML (strml.github.com)
 * MIT License
 *
 * To use: textFit(document.getElementById('target-div'), options);
 *
 * Will make the *text* content inside a container scale to fit the container
 * The container is required to have a set width and height
 * Uses binary search to fit text with minimal layout calls.
 * Version 2.0 does not use jQuery.
 */
/*global define:true, document:true, window:true, HTMLElement:true*/

(function(root, factory) {
  "use strict";

  // UMD shim
  if (typeof define === "function" && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof exports === "object") {
    // Node/CommonJS
    module.exports = factory();
  } else {
    // Browser
    root.textFit = factory();
  }

}(typeof global === "object" ? global : this, function () {
  "use strict";

  var defaultSettings = {
    alignVert: false, // if true, textFit will align vertically using css tables
    alignHoriz: false, // if true, textFit will set text-align: center
    multiLine: false, // if true, textFit will not set white-space: no-wrap
    detectMultiLine: true, // disable to turn off automatic multi-line sensing
    minFontSize: 6,
    maxFontSize: 80,
    reProcess: true, // if true, textFit will re-process already-fit nodes. Set to 'false' for better performance
    widthOnly: false // if true, textFit will fit text to element width, regardless of text height
  };

  return function textFit(els, options) {

    if (!options) options = {};

    // Extend options.
    var settings = {};
    for(var key in defaultSettings){
      if(options.hasOwnProperty(key)){
        settings[key] = options[key];
      } else {
        settings[key] = defaultSettings[key];
      }
    }

    // Convert jQuery objects into arrays
    if (typeof els.toArray === "function") {
      els = els.toArray();
    }

    // Support passing a single el
    var elType = Object.prototype.toString.call(els);
    if (elType !== '[object Array]' && elType !== '[object NodeList]'){
      els = [els];
    }

    // Process each el we've passed.
    for(var i = 0; i < els.length; i++){
      processItem(els[i], settings);
    }
  };

  /**
   * The meat. Given an el, make the text inside it fit its parent.
   * @param  {DOMElement} el       Child el.
   * @param  {Object} settings     Options for fit.
   */
  function processItem(el, settings){
    if (!isElement(el) || (!settings.reProcess && el.getAttribute('textFitted'))) {
      return false;
    }

    // Set textFitted attribute so we know this was processed.
    if(!settings.reProcess){
      el.setAttribute('textFitted', 1);
    }

    var innerSpan, originalHeight, originalHTML, originalWidth;
    var low, mid, high;

    // Get element data.
    originalHTML = el.innerHTML;
    originalWidth = innerWidth(el);
    originalHeight = innerHeight(el);

    // Don't process if we can't find box dimensions
    if (!originalWidth || (!settings.widthOnly && !originalHeight)) {
      if(!settings.widthOnly)
        throw new Error('Set a static height and width on the target element ' + el.outerHTML +
          ' before using textFit!');
      else
        throw new Error('Set a static width on the target element ' + el.outerHTML +
          ' before using textFit!');
    }

    // Add textFitted span inside this container.
    if (originalHTML.indexOf('textFitted') === -1) {
      innerSpan = document.createElement('span');
      innerSpan.className = 'textFitted';
      // Inline block ensure it takes on the size of its contents, even if they are enclosed
      // in other tags like <p>
      innerSpan.style['display'] = 'inline-block';
      innerSpan.innerHTML = originalHTML;
      el.innerHTML = '';
      el.appendChild(innerSpan);
    } else {
      // Reprocessing.
      innerSpan = el.querySelector('span.textFitted');
      // Remove vertical align if we're reprocessing.
      if (hasClass(innerSpan, 'textFitAlignVert')){
        innerSpan.className = innerSpan.className.replace('textFitAlignVert', '');
        innerSpan.style['height'] = '';
      }
    }

    // Prepare & set alignment
    if (settings.alignHoriz) {
      el.style['text-align'] = 'center';
      innerSpan.style['text-align'] = 'center';
    }

    // Check if this string is multiple lines
    // Not guaranteed to always work if you use wonky line-heights
    var multiLine = settings.multiLine;
    if (settings.detectMultiLine && !multiLine &&
        innerSpan.scrollHeight >= parseInt(window.getComputedStyle(innerSpan)['font-size'], 10) * 2){
      multiLine = true;
    }

    // If we're not treating this as a multiline string, don't let it wrap.
    if (!multiLine) {
      el.style['white-space'] = 'nowrap';
    }

    low = settings.minFontSize + 1;
    high = settings.maxFontSize + 1;

    // Binary search for best fit
    while (low <= high) {
      mid = parseInt((low + high) / 2, 10);
      innerSpan.style.fontSize = mid + 'px';
      if(innerSpan.scrollWidth <= originalWidth && (settings.widthOnly || innerSpan.scrollHeight <= originalHeight)){
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    // Sub 1 at the very end, this is closer to what we wanted.
    innerSpan.style.fontSize = (mid - 1) + 'px';

    // Our height is finalized. If we are aligning vertically, set that up.
    if (settings.alignVert) {
      addStyleSheet();
      var height = innerSpan.scrollHeight;
      if (window.getComputedStyle(el)['position'] === "static"){
        el.style['position'] = 'relative';
      }
      if (!hasClass(innerSpan, "textFitAlignVert")){
        innerSpan.className = innerSpan.className + " textFitAlignVert";
      }
      innerSpan.style['height'] = height + "px";
    }
  }

  // Calculate height without padding.
  function innerHeight(el){
    var style = window.getComputedStyle(el, null);
    return el.clientHeight -
      parseInt(style.getPropertyValue('padding-top'), 10) -
      parseInt(style.getPropertyValue('padding-bottom'), 10);
  }

  // Calculate width without padding.
  function innerWidth(el){
    var style = window.getComputedStyle(el, null);
    return el.clientWidth -
      parseInt(style.getPropertyValue('padding-left'), 10) -
      parseInt(style.getPropertyValue('padding-right'), 10);
  }

  //Returns true if it is a DOM element
  function isElement(o){
    return (
      typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
      o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName==="string"
    );
  }

  function hasClass(element, cls) {
    return (' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }

  // Better than a stylesheet dependency
  function addStyleSheet() {
    if (document.getElementById("textFitStyleSheet")) return;
    var style = [
      ".textFitAlignVert{",
        "position: absolute;",
        "top: 0; right: 0; bottom: 0; left: 0;",
        "margin: auto;",
      "}"].join("");

    var css = document.createElement("style");
    css.type = "text/css";
    css.id = "textFitStyleSheet";
    css.innerHTML = style;
    document.body.appendChild(css);
  }
}));

// paramètres:
// - liste de hashtags, pour récupérer en mode public de twitter, instagram, vine
// - liste de user, pour récupérer tout le contenu d'un utilisateur en particulier de twitter, instagram,vine
// - temps de départ
// - polling depuis le navigateur

// concept de source, initialisée une fois avec les paramètres, expose une fonction update qui renvoie les nouveaux tweets et update le dernier timestamp de mise à jour

// concept d'item contenant à chaque fois:
// -- liste de vidéos
// -- liste images
// -- liste textes
// -- nombre de comments
// -- nombre de like
// -- nombre de partages



SourceVine = function(params){

	var urlNewByTag 	= 'https://api.vineapp.com/timelines/tags/%tag%';
	var urlNewByUser 	= 'https://api.vineapp.com/timelines/users/%user-id%';

	var lowestId = {}; // By tag or user last item id
	var highestId = {};

	var consumedId = [];

	var maxAnchor = {};

	var postFormatter = function(post){

		var item = {
			id 			: (post.postId).toString(),
			date 		: new Date(post.created),
			nLikes		: post.likes.count,
			nComments	: post.comments.count,
			nShares		: post.reposts.count,
			video		: [
			{
				url:post.videoDashUrl,
				width:null,
				height:null
			}],
			image:null,
			text 		: post.hasOwnProperty("description") === true && post.description ? [post.description] : null,
			user 		: {
				name		: post.username,
				profilePic 	: post.avatarUrl
			}
		}

		return item;
	}

	var getNext = function(newPosts,remaining,isFirst,nextPage,curChannel,callback)
	{
		var getParams;

		if(isFirst) // Get latest post only, no need to specify min_tag_id
		{
			// console.log("**************"+highestId[curChannel]);
			if(highestId[curChannel] !== null)
				getParams = {
					// access_token	: this.token,
					anchor		: maxAnchor[curChannel]
				}
			else
				getParams = {
					// access_token	: this.token
				}
		}
		else
			getParams = {
				// access_token	: this.token
				// max_tag_id		: lowestId[curChannel]
			}

		var getUrl = curChannel.indexOf('#') !== -1 ? urlNewByTag.replace('%tag%',curChannel).replace('#',''):urlNewByUser.replace('%user-id%',curChannel);

		// if(nextPage !== null || highestId[curChannel] !== null)
		// 	getUrl += '?page='+nextPage;

		console.log("Next url:" +getUrl);		

		$.get(getUrl,getParams).done((function(data){

			console.log("[Vine] Got from "+getUrl+":");

			var items 		= data.data.records;				

			// console.log(data);

			isFirst 	= false;
			nextPage 	= data.data.nextPage;

			for(var dataIndex in items)
			{
				var post = postFormatter(items[dataIndex]);

				// console.log("**********************");
				// console.log(consumedId);
				// console.log(post.id);




				/* If post too old, or if we alreay have it */
				if(post.date < this.since)
				{
					console.log("Date inferior to since param")
					nextPage = null;
					break;				
				}

				if(post.id < highestId[curChannel] && post.id > lowestId[curChannel])
				{			
					console.log("Id in range we alreay have: "+lowestId[curChannel]+" < "+post.id+" < "+highestId[curChannel]);
					// isNext = false;
					// break;
				}

				if(remaining <= 0)
				{
					console.log("No post remaining")					
					nextPage = null;
					break;
				}

				if(consumedId.indexOf(post.id) !== -1)
				{
					console.log("[Vine] post already consumed")
					continue;
				}
				// console.log(consumedId[curChannel].indexOf(post.id));
				// console.log("[Vine] adding post with ID "+post.id)

				consumedId.push(post.id);

				maxAnchor[curChannel] = data.data.backAnchor;

				// console.log("**********************************"+maxAnchor)

				if(highestId[curChannel] === null || highestId[curChannel] < post.id)
					highestId[curChannel] = post.id;

				if(lowestId[curChannel] === null || lowestId[curChannel] > post.id)
					lowestId[curChannel] = post.id;				


				// console.log(highestId[curChannel]);


				newPosts.push(post);
				remaining--;
			}

			console.log("[Vine] Looping: "+(nextPage !== null)+" remaining: "+remaining);

			if(nextPage !== null)
				getNext.call(this,newPosts,remaining,isFirst,nextPage,curChannel,callback);
			else
				callback('vine',curChannel,newPosts);

		}).bind(this));
	}

	this.getNew = function(callback){

		var currentLimit = this.perFetchLimit;

		var newPosts = [];

		for(var channelId in this.channels)
		{
			var curChannel = this.channels[channelId];

			if(!lowestId.hasOwnProperty(curChannel))
				lowestId[curChannel] = null;

			if(!highestId.hasOwnProperty(curChannel))
				highestId[curChannel] = null;

			var nextPage = null;
			var isFirst = true;

			console.log("[Vine] Getting "+curChannel);

			getNext.call(this,newPosts,currentLimit,isFirst,nextPage,curChannel,callback);
		}
	}

	this.channels 		= params.hasOwnProperty("channels") ? params.channels : null;
	this.since 			= params.hasOwnProperty("since") ? params.since : null;
	this.perFetchLimit 	= params.hasOwnProperty("perFetchLimit") ? params.perFetchLimit : null;
}

SourceInstagram = function(params){

	var urlNewByTag 	= 'https://api.instagram.com/v1/tags/%tag%/media/recent/';
	var urlNewByUser 	= 'https://api.instagram.com/v1/users/%user-id%/media/recent/';

	var lowestId = {}; // By tag or user last item id
	var highestId = {};

	var next_min_tag_id = {};
	var next_max_tag_id = {};

	var consumedId = [];

	var postFormatter = function(post){
		// console.log(post.caption);

		var item = {
			id 			: (post.id).toString(),
			date 		: new Date(post.created_time*1000),
			nLikes		: post.likes.count,
			nComments	: post.comments.count,
			nShares		: null,
			video		: post.type == 'video' ? [
			{
				url:post.videos.standard_resolution.url,
				width:post.videos.standard_resolution.width,
				height:post.videos.standard_resolution.height
			}]:null,
			image 		: post.type == 'image' ? [
			{
				url:post.images.standard_resolution.url,
				width:post.images.standard_resolution.width,
				height:post.images.standard_resolution.height
			}]:null,
			text 		: post.hasOwnProperty("caption") === true && post.caption && post.caption.hasOwnProperty("text") ? [post.caption.text] : null,
			user 		: {
				name		: post.user.username,
				profilePic 	: post.user.profile_picture
			}
		}

		return item;
	}

	var getNext = function(newPosts,remaining,isFirst,nextUrl,curChannel,callback)
	{
		var getParams;

		if(isFirst) // Get latest post only, no need to specify min_tag_id
		{
			if(highestId[curChannel] !== null)
				getParams = {
					access_token	: this.token,
					min_tag_id		: next_min_tag_id, //highestId[curChannel]
				}
			else
				getParams = {
					access_token	: this.token
				}
		}
		else
			getParams = {
				access_token	: this.token,
				max_tag_id		: next_max_tag_id
			}

		var getUrl = curChannel.indexOf('#') !== -1 ? urlNewByTag.replace('%tag%',curChannel).replace('#',''):urlNewByUser.replace('%user-id%',curChannel);

		// if(nextUrl !== null)
		// 	getUrl = nextUrl;

		// console.log("Next url:" +getUrl);		

		$.get(getUrl,getParams).done((function(data){

			// console.log("[Instagram] Got from "+nextUrl+":");

			var items 		= data.data;				

			// console.log(items);

			isFirst 		= false;
			nextUrl 		= items.hasOwnProperty("nextPage") ? items.nextPage : null;	

			if(data.pagination.hasOwnProperty("next_min_id"))
				next_min_tag_id[curChannel] 	= data.pagination.next_min_id;

			if(data.pagination.hasOwnProperty("next_max_id"))
				next_max_tag_id[curChannel] 	= data.pagination.next_max_id;

			for(var dataIndex in items)
			{
				var post = postFormatter(items[dataIndex]);

				/* If post too old, or if we alreay have it */
				if(post.date < this.since)
				{
					// console.log("Date inferior to since param")
					nextUrl = null;
					break;				
				}

				if(post.id < highestId[curChannel] && post.id > lowestId[curChannel])
				{			
					// console.log("Id in range we alreay have: "+lowestId[curChannel]+" < "+post.id+" < "+highestId[curChannel]);
					// isNext = false;
					// break;
				}

				if(remaining <=0)
				{
					// console.log("No post rmainning")					
					nextUrl = null;
					break;
				}

				if(consumedId.indexOf(post.id) !== -1)
				{
					console.log("[Instagram] Already consumed")					
					continue;
				}

				consumedId.push(post.id);				

				// console.log(post);

				if(highestId[curChannel] === null || highestId[curChannel] < post.id)
					highestId[curChannel] = post.id;

				if(lowestId[curChannel] === null || lowestId[curChannel] > post.id)
					lowestId[curChannel] = post.id;				

				newPosts.push(post);
				remaining--;
			}


			if(nextUrl !== null)
			{
				console.log("[Instagram] Looping. Remaining: "+remaining);					
				getNext.call(this,newPosts,remaining,isFirst,nextUrl,curChannel,callback);
			}
			else
			{
				console.log("[Instagram] Callback with "+newPosts.length+" items ");							
				callback('instagram',curChannel,newPosts);
			}

		}).bind(this));
	}

	this.getNew = function(callback){

		var currentLimit = this.perFetchLimit;

		var newPosts = [];

		for(var channelId in this.channels)
		{
			var curChannel = this.channels[channelId];

			if(!lowestId.hasOwnProperty(curChannel))
				lowestId[curChannel] = null;

			if(!highestId.hasOwnProperty(curChannel))
				highestId[curChannel] = null;

			var nextUrl = null;
			var isFirst = true;

			// console.log("[Instagram] Getting "+curChannel);

			getNext.call(this,newPosts,currentLimit,isFirst,nextUrl,curChannel,callback);
		}
	}

	this.token 			= params.hasOwnProperty("token") ? params.token : null;
	this.channels 		= params.hasOwnProperty("channels") ? params.channels : null;
	this.since 			= params.hasOwnProperty("since") ? params.since : null;
	this.perFetchLimit 	= params.hasOwnProperty("perFetchLimit") ? params.perFetchLimit : null;
}

var appendItems = function(source,channel,posts){

		// console.log(posts);

	$.each(posts,function(index,v){

		var caption = '';

		if(v.text !== null)
			caption += v.text.join(' ');

		caption = caption.replace(/([^ ])#/gi,'$1 #').replace('"','').replace(/([^ ]{20})/ig,'$1 ');

		if(caption.length > 400)
			caption = caption.substring(0,400)+'...';

		var smallItemSize = 120;
		var mediumItemSize = 240;
		var bigItemSize = 480;

		var verbosity = caption.length > 250 ? 'long' : caption.length > 100 ? 'medium' : 'short';
		var size = v.nLikes < 2 && v.nShares < 2 ? verbosity !== 'long' ? /*'small'*/ 'medium' : 'medium' : Math.random() > 0.5 ? 'big' : 'medium';
		var layout = size=='small' ? Math.random() > 0.5 ? 'landscape' : 'portrait'  : verbosity == 'short' ? 'square' : Math.random() > 0.5 ? 'landscape' : 'portrait';

		var item_grid_class =  size+'-'+layout;

		var captionWidth = size == 'small' ? smallItemSize : size == 'medium' ? mediumItemSize : bigItemSize;
		var captionHeight = size == 'small' ? (layout == 'square' ? 40 : smallItemSize) : size == 'medium' ? (layout == 'square' ? 80 : mediumItemSize) : (layout == 'square' ? 100 : bigItemSize);
		var captionLeft = size == 'small' ? (layout == 'landscape' ? smallItemSize : 0) : size == 'medium' ? (layout == 'landscape' ? mediumItemSize : 0) : (layout == 'landscape' ? bigItemSize : 0);
		var captionBottom = 0;//size == 'small' ? (layout == 'portrait' ? 0 : 015) : size == 'medium' ? (layout == 'portrait' ? mediumItemSize : 0) : (layout == 'portrait' ? bigItemSize : 0);

		var captionPadding = size == 'small' ? '10px' : size == 'medium' ? '20px' : '30px';

		var mediaWidth = layout === 'landscape' ? '50%' : '100%';

		var triangleWidth = layout == 'landscape' ? size == 'small' ? 20 : size == 'medium' ? 30 : 40 : captionWidth;
		var triangleHeight = layout == 'landscape' ? captionHeight : size == 'small' ? 10 : size == 'medium' ? 20 : 40;
		var triangleLeft = layout == 'landscape' ? captionWidth - triangleWidth : 0;
		var triangleTop = layout == 'portrait' ? captionHeight - triangleHeight -10: layout == 'landscape' ? 0 : size == 'small' ? smallItemSize-captionHeight-triangleHeight -10: size == 'medium' ? mediumItemSize-captionHeight-triangleHeight : bigItemSize-captionHeight-triangleHeight;

		// var logoLeft = layout == 'portrait' ? :
		// var logoLeftInc = layout == 'portrait' ? 0

		var cRand = Math.random();

  		var colorClass = cRand > 0.66 ? 'color-1' : cRand > 0.33 ? 'color-2' : 'color-3';
  		var color = cRand > 0.66 ? 'rgba(37, 170, 255,1)' : cRand > 0.33 ? 'rgba(236, 0, 140,1)' : 'rgba(140, 198, 63,1)';		

  		var triangleStyle = '';

		if(layout == 'landscape')
			triangleStyle="border-width:"+triangleHeight/2+"px "+triangleWidth+"px "+triangleHeight/2+"px 0;border-color: transparent "+color+" transparent transparent;";
		else
			triangleStyle="border-width:0 "+triangleWidth/2+"px "+triangleHeight+"px "+triangleWidth/2+"px;border-color: transparent transparent "+color+" transparent;";


		var waitingElems = 0;  		

		// <span class="likes">'+v.nLikes+'</span>

		var item = $('<div class="grid-item '+item_grid_class+' size-'+size+' '+colorClass+'">\
			<img class="source" src="./'+source+'.png" style="left:'+(captionWidth-30)+'px;" />\
			<div class="triangle" style="'+triangleStyle+'left:'+triangleLeft+';top:'+triangleTop+'px"></div>\
			</div>');

		if(v.date !== null)
			item.append('<p class="date '+colorClass+'" style="width:'+captionWidth+'">'+moment(v.date).fromNow()+'</p>');

		if(caption !== null)
			item.append('<p style="width:'+captionWidth+'px;height:'+captionHeight+'px;left:'+captionLeft+'px;bottom:'+captionBottom+';padding:'+captionPadding+';" class="caption '+colorClass+'"><b>'+v.user.name+'</b><br /><br >'+caption+'</p>');	

		var img = $('<img class="media" style="width:'+mediaWidth+'" />');
		var video = $('<video class="media" style="width:'+mediaWidth+'" type="video/mp4" loop muted autoplay><video>');		

		if(v.image !== null)
		{
			console.log("[Instagram] Waiting for img to be loaded");				

			img.load(function(){

				waitingElems--;

				// console.log("[Instagram] img loaded");				

				if(waitingElems===0)
				{
					// console.log("[Instagram] Appending item");
					grid.prepend(item).packery('prepended',item);
					textFit($(item).find('p.caption')[0]);
				}

			});	

			waitingElems++;
			
			img.attr('src',v.image[0].url);

			item.append(img);
		}

		if(v.video !== null)
		{
			console.log("[Instagram] Waiting for vid to be loaded");							

			video[0].addEventListener('loadedmetadata', function () {

				waitingElems--;

				console.log("[Instagram] vid loaded");				

				if(waitingElems===0)
				{
					console.log("[Instagram] Appending item");					
					grid.prepend(item).packery('prepended',item);
								textFit($(item).find('p.caption')[0]);

				}

			});

			waitingElems++;	

			video.attr('src',v.video[0].url);

			video[0].load();

			item.append(video);
		}

	});

	$.each($('.grid-item'),function(index,item){

		var offset = $(item).offset();

		if(offset.top > $(window).height()*3)
		{
			console.log("[Wall] Removing old media, offset "+$(item).offset().top);
			try
			{		
				grid.remove($(item));
			}
			catch(e)
			{}

			$(item).remove();
		}
	})

	// console.log(channel);
}

var instagram = new SourceInstagram({
	token:			'510573486.ab7d4b6.d8b155be5d1a47c78f72616b4d942e8d',
	channels:		['#fashionaddict'],
	since:			new Date(0),
	perFetchLimit: 	10});

// var vine = new SourceVine({
// 	channels:		['#lol'],
// 	since:			new Date(),
// 	perFetchLimit: 	1});

// instagram.getNew(appendItems);
// vine.getNew(appendItems);


// window.setInterval(function(){
// 	vine.getNew(appendItems);
// },1000);

window.setInterval(function(){
	instagram.getNew(appendItems);
},1000);



// returns [
// 	{	'video':[],
// 		'image':[],
// 		'text':[],
// 		'comment':[],
// 		'like':1000,
// 		'share':2000
// 	}
// ]
</script>